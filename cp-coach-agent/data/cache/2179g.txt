{
    "analysis": {
        "hints": {
            "level1": "The problem asks us to reconstruct the grid of penguin positions, preserving Manhattan distances. Manhattan distance `dist((r1, c1), (r2, c2)) = |r1 - r2| + |c1 - c2|`.",
            "level2": "Manhattan distances have a useful property when transforming coordinates: `dist((r1, c1), (r2, c2)) = 0.5 * (| (r1+c1) - (r2+c2) | + | (r1-c1) - (r2-c2) |)`. Let `X_k = r_k + c_k` and `Y_k = r_k - c_k`. Then `dist(k1, k2) = 0.5 * (|X_k1 - X_k2| + |Y_k1 - Y_k2|)`. We need to find `(r_k, c_k)` for each penguin `k`, which is equivalent to finding `(X_k, Y_k)` and then converting back (`r_k = (X_k+Y_k)/2`, `c_k = (X_k-Y_k)/2`).",
            "level3": "To uniquely determine a point's coordinates in a 2D plane (even with a transformation like `(X,Y)` coordinates), three non-collinear reference points are typically sufficient. We can fix three specific grid cells in our target grid `b`, say `(1,1)`, `(1,2)`, and `(2,1)`, and assume they are occupied by some specific penguins. Let these target cells correspond to `(X_A, Y_A) = (2,0)`, `(X_B, Y_B) = (3,-1)`, and `(X_C, Y_C) = (3,1)` respectively.",
            "level4": "The challenge is to identify which penguins (by their labels from 1 to N^2) correspond to these three reference points in the hidden grid `a`. We need to find three labels `L_A, L_B, L_C` from `1...N^2` such that their inter-Manhattan distances match those of `(1,1), (1,2), (2,1)`. That is, `dist(L_A, L_B)=1`, `dist(L_A, L_C)=1`, and `dist(L_B, L_C)=2`. We can find such `L_A, L_B, L_C` by picking an arbitrary penguin (say, label 1) as a candidate for `L_A`, querying its distance to all other penguins, identifying its neighbors (distance 1), and then from those neighbors, finding two that are distance 2 apart.",
            "level5": "Once `L_A, L_B, L_C` are identified, we query `dist(L_A, k)`, `dist(L_B, k)`, and `dist(L_C, k)` for every penguin `k` (from 1 to N^2). This provides three distance values for each `k`. For each possible cell `(r,c)` in the `N x N` grid, we can precompute the triplet of distances it would have from `(1,1)`, `(1,2)`, and `(2,1)`. We store these precomputed triplets in a map. Then, for each penguin `k`, we use its queried distance triplet to look up its unique `(r,c)` position in the map, thereby reconstructing the grid `b`."
        },
        "summary": {
            "problem_statement": "Blackslex is researching penguins on an N x N grid island, with one penguin per cell. Each penguin is labeled 1 to N^2. After migration, all N^2 penguins are still in distinct cells. We need to find the current N x N grid `b` representing penguin positions, such that for any two penguins `i` and `j`, their Manhattan distance in `b` (denoted `dist(b,i,j)`) is equal to their Manhattan distance in the hidden grid `a` (`dist(a,i,j)`). We can make at most `3N^2 + 150` queries of the form `? i j` to get `dist(a,i,j)`. After queries, output `!`, then the N x N grid `b`.",
            "input_format": {
                "description": "Multiple test cases. First line: `t` (number of test cases). For each test case: a single integer `n` (grid size).",
                "structure": [
                    "t (integer)",
                    "n (integer) for each test case"
                ]
            },
            "output_format": {
                "description": "For each test case: series of queries `? i j` followed by responses. After determining the grid, output `!`, then `n` lines, each with `n` integers representing the reconstructed grid `b`.",
                "structure": [
                    "\"? i j\" (query)",
                    "distance (integer, response)",
                    "\"!\"",
                    "n lines of n integers (grid b)"
                ]
            },
            "constraints": {
                "time_limit": "5 seconds",
                "memory_limit": "256 megabytes",
                "bounds": [
                    "1 <= t <= 200",
                    "2 <= n <= 100",
                    "Total sum of n across all test cases <= 500",
                    "Max 3n^2 + 150 queries per test case"
                ]
            },
            "sample_cases": [
                {
                    "input": "2\n2\n3",
                    "output": "? 1 2\n1\n? 1 3\n2\n? 1 4\n1\n? 2 3\n1\n? 2 4\n2\n? 3 4\n1\n!\n3 4\n2 1\n? 1 8\n3\n!\n9 1 3\n4 2 7\n8 5 6"
                }
            ],
            "key_requirements": [
                "Reconstruct a valid N x N grid `b`.",
                "Every cell in `b` must contain a unique penguin label from 1 to N^2.",
                "For all 1 <= i,j <= N^2, `dist(a,i,j) = dist(b,i,j)`.",
                "Adhere strictly to query limit (3N^2 + 150).",
                "Interactive problem: flush output after each query."
            ]
        },
        "analysis": {
            "key_observation": "The Manhattan distance `dist((r1, c1), (r2, c2))` relates to transformed coordinates `(X=r+c, Y=r-c)` by the formula `dist = 0.5 * (|X1-X2| + |Y1-Y2|)`. This means `(X,Y)` pairs for each penguin can be uniquely determined if we can establish 3 non-collinear reference points. We assign specific labels to target positions `(1,1), (1,2), (2,1)` in `b` (which correspond to `(X,Y)` coordinates `(2,0), (3,-1), (3,1)` respectively) and then deduce all other penguin positions based on queried distances to these reference penguins.",
            "edge_cases": [
                "Smallest N=2: The strategy relies on finding three distinct penguins whose relative distances match `(1,1), (1,2), (2,1)`. For N=2, there are only 4 penguins in total. This method still works as three penguins will always satisfy the distance criteria if they are appropriately chosen as `L_A, L_B, L_C` for a specific configuration.",
                "All `N^2` penguins must be placed and unique.",
                "The choice of `L_A, L_B, L_C` could map a rotated/reflected version of `a` to `b`. This is fine as long as distances are preserved."
            ],
            "naive_failures": [
                "Brute-forcing all possible grid configurations for `b` is `(N^2)!` permutations, too slow.",
                "Trying to query distances between all pairs of penguins (`N^2 * (N^2-1) / 2` queries) exceeds the limit for larger N (e.g., `100^4` is too much, `3N^2` is allowed).",
                "Arbitrarily assigning penguin labels 1, 2, 3 to `(1,1), (1,2), (2,1)` without checking their `dist(a,i,j)` properties might lead to an invalid `b` for `dist(a,i,j) = dist(b,i,j)`."
            ],
            "problem_category": {
                "primary": "Interactive",
                "secondary": [
                    "Graph Theory",
                    "Coordinate Geometry",
                    "Algorithm Design"
                ],
                "subcategory": "Distance Queries"
            },
            "complexity_analysis": {
                "constraints": {
                    "N_max": 100,
                    "Total_N_sum": 500,
                    "Queries_max": "3N^2 + 150"
                },
                "expected_time": "O(N^2) per test case (dominated by querying and map operations). Total time complexity: O(sum N^2).",
                "expected_space": "O(N^2) per test case (for storing grid, penguin positions, and distance caches, and the `cell_dist_to_rc` map). This is `100*100 = 10000` elements, which is well within 256MB."
            }
        },
        "solution": {
            "language": "C++",
            "approach": "Identify three reference penguins (labels `L_A, L_B, L_C`) in the hidden grid `a` whose relative Manhattan distances match those of cells `(1,1), (1,2), (2,1)` in a target grid `b`. Then, for every penguin `k`, query its Manhattan distance to `L_A`, `L_B`, and `L_C`. Precompute a map from these distance triplets to unique `(r,c)` coordinates in `b` to reconstruct the final grid.",
            "time_complexity": "O(N^2) per test case",
            "space_complexity": "O(N^2) per test case",
            "key_insights": [
                "The Manhattan distance property: `dist((r1,c1),(r2,c2)) = 0.5 * (| (r1+c1)-(r2+c2) | + | (r1-c1)-(r2-c2) |)`.",
                "Three non-collinear reference points are sufficient to uniquely determine a point's coordinates (up to reflection/rotation in Euclidean geometry, and similarly for Manhattan distance in transformed coordinates).",
                "We can identify the `L_A, L_B, L_C` labels by finding a penguin `L_A` (e.g., label 1) and two of its direct neighbors, `L_B` and `L_C`, such that `dist(L_B, L_C) = 2` (implying they are 'L-shaped' from `L_A`).",
                "Total queries: `(N^2-1)` to find `L_A`'s neighbors, `O(N)` for finding `L_B, L_C` from `L_A`'s neighbors, and `2*(N^2-1)` for final distance queries for all penguins to `L_B` and `L_C`. This totals to `3N^2 + O(N)` queries, which is within limits."
            ],
            "code": "N/A",
            "explanation": {
                "algorithm_steps": [
                    "**1. Precompute Reference Map:** Create `map<tuple<int, int, int>, pair<int, int>> cell_dist_to_rc`. For every cell `(r,c)` from `(1,1)` to `(n,n)`:",
                    "   Calculate `d_A = abs(r-1) + abs(c-1)` (distance to `(1,1)`).",
                    "   Calculate `d_B = abs(r-1) + abs(c-2)` (distance to `(1,2)`).",
                    "   Calculate `d_C = abs(r-2) + abs(c-1)` (distance to `(2,1)`).",
                    "   Store `cell_dist_to_rc[{d_A, d_B, d_C}] = {r, c}`. This map will uniquely identify a cell by its distances to the three fixed reference points.",
                    "**2. Identify Reference Penguin Labels (`L_A, L_B, L_C`):**",
                    "   Set `L_A = 1` (arbitrarily pick penguin 1 as one reference).",
                    "   Initialize `dist_from_1[N*N+1]` array to store `dist(1, k)` values. Initialize `neighbors_of_1` vector.",
                    "   For `k` from 2 to `N^2`: Query `d = ? 1 k`. Store `dist_from_1[k] = d`. If `d == 1`, add `k` to `neighbors_of_1`. (This uses `N^2-1` queries).",
                    "   Set `dist_from_1[1] = 0`.",
                    "   Iterate through `l2` in `neighbors_of_1`:",
                    "     Iterate through `l3` in `neighbors_of_1`:",
                    "       If `l2 == l3`, continue.",
                    "       Query `d_l2_l3 = ? l2 l3`. (These queries are `O(N^2)` in worst-case, for `N` elements in `neighbors_of_1` can be `2N-2` for `N>=2`).",
                    "       If `d_l2_l3 == 2`: We have found our labels! `L_A = 1`, `L_B = l2`, `L_C = l3`. Break both loops.",
                    "**3. Query All Penguins' Distances to Reference Labels:**",
                    "   Initialize `actual_d_A[N*N+1]`, `actual_d_B[N*N+1]`, `actual_d_C[N*N+1]` arrays.",
                    "   For `k` from 1 to `N^2`:",
                    "     `actual_d_A[k] = (k == L_A) ? 0 : dist_from_1[k]` (reusing cached distance from Step 2).",
                    "     `actual_d_B[k] = (k == L_B) ? 0 : query(L_B, k)`.",
                    "     `actual_d_C[k] = (k == L_C) ? 0 : query(L_C, k)`.",
                    "   This step adds `2 * (N^2 - 1)` new queries (since `dist_from_1[k]` is used for `L_A` and for `L_B` or `L_C` if they happen to be 1).",
                    "**4. Reconstruct and Output Grid `b`:**",
                    "   Initialize an `N x N` grid `result_grid`.",
                    "   For `k` from 1 to `N^2`:",
                    "     Use `cell_dist_to_rc[{actual_d_A[k], actual_d_B[k], actual_d_C[k]}]` to find the unique `(r,c)` coordinates for penguin `k`.",
                    "     Set `result_grid[r][c] = k`.",
                    "   Output `!` and then print `result_grid`."
                ],
                "edge_cases_handled": [
                    "Smallest `N=2`: The logic correctly identifies neighbors and finds the triplet `(L_A, L_B, L_C)` if N is large enough to have at least three distinct cells for this L-shape. For `N=2`, the maximum number of neighbors for `(1,1)` is 2 (`(1,2)` and `(2,1)`). The algorithm finds these two neighbors and queries their distance, which is 2. So the triplet is found.",
                    "Query count: The total query count is `(N^2-1)` (Step 2.1) + `O(N^2)` (Step 2.2, max `(2N-2)*(2N-3)` for finding `L_B,L_C`) + `2*(N^2-1)` (Step 3). This is approximately `3N^2 + O(N^2)` in the absolute worst case for finding `L_B, L_C`, but realistically `O(N)` since `neighbors_of_1` is small. Max queries `3N^2 - 3`, well within `3N^2 + 150`."
                ]
            },
            "test_verification": {}
        }
    },
    "code": "#include <bits/stdc++.h>\n\nint query(int i, int j) {\n    std::cout << \"? \" << i << \" \" << j << std::endl;\n    int dist;\n    std::cin >> dist;\n    return dist;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    int n_squared = n * n;\n\n    std::vector<int> d1_k(n_squared + 1);\n    \n    int p1 = 1;\n    d1_k[p1] = 0;\n\n    int p_ref = -1; \n\n    for (int k = 1; k <= n_squared; ++k) {\n        if (k == p1) continue;\n        d1_k[k] = query(p1, k);\n        if (d1_k[k] == n - 1) {\n            if (p_ref == -1) { \n                p_ref = k;\n            }\n        }\n    }\n\n    std::vector<int> d_ref_k(n_squared + 1);\n    d_ref_k[p_ref] = 0;\n\n    for (int k = 1; k <= n_squared; ++k) {\n        if (k == p_ref) continue;\n        d_ref_k[k] = query(p_ref, k);\n    }\n    \n    std::vector<std::vector<int>> result_grid(n, std::vector<int>(n));\n\n    for (int k = 1; k <= n_squared; ++k) {\n        int r_k, c_k;\n        if (k == p1) {\n            r_k = 0;\n            c_k = 0;\n        } else if (k == p_ref) {\n            r_k = 0;\n            c_k = n - 1;\n        } else {\n            // Let (R_k, C_k) be the coordinates of penguin k.\n            // d1_k[k] = |R_k - R_p1| + |C_k - C_p1|\n            // Assuming (R_p1, C_p1) = (0,0), then d1_k[k] = R_k + C_k.\n            //\n            // d_ref_k[k] = |R_k - R_pref| + |C_k - C_pref|\n            // Assuming (R_pref, C_pref) = (0, n-1), then d_ref_k[k] = R_k + |C_k - (n-1)|.\n            // Since 0 <= C_k < n, |C_k - (n-1)| = (n-1) - C_k.\n            // So d_ref_k[k] = R_k + (n-1) - C_k.\n\n            // We have a system of two linear equations:\n            // 1) R_k + C_k = d1_k[k]\n            // 2) R_k - C_k + (n-1) = d_ref_k[k]  => R_k - C_k = d_ref_k[k] - (n-1)\n\n            // Add (1) and (2'):\n            // (R_k + C_k) + (R_k - C_k) = d1_k[k] + (d_ref_k[k] - (n-1))\n            // 2 * R_k = d1_k[k] + d_ref_k[k] - (n-1)\n            r_k = (d1_k[k] + d_ref_k[k] - (n - 1)) / 2;\n\n            // Subtract (2') from (1):\n            // (R_k + C_k) - (R_k - C_k) = d1_k[k] - (d_ref_k[k] - (n-1))\n            // 2 * C_k = d1_k[k] - d_ref_k[k] + (n-1)\n            c_k = (d1_k[k] - d_ref_k[k] + (n - 1)) / 2;\n        }\n        result_grid[r_k][c_k] = k;\n    }\n\n    std::cout << \"!\" << std::endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::cout << result_grid[i][j] << (j == n - 1 ? \"\" : \" \");\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}"
}