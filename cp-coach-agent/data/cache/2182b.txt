{
    "analysis": {
        "hints": {
            "level1": "Understand how layer sizes grow: they are powers of 2 (1, 2, 4, 8, ...). This is a geometric progression, specifically 2^0, 2^1, 2^2, and so on.",
            "level2": "The chocolate types must strictly alternate. This means if the top layer is white, the next must be dark, the next white, and so forth. If the top layer is dark, the pattern is dark, white, dark, ...",
            "level3": "There are only two possible valid coloring patterns for any number of layers: either the topmost layer is white, or the topmost layer is dark. For each pattern, you can calculate the total white and dark chocolate needed.",
            "level4": "Iteratively try to build cakes with an increasing number of layers (1, 2, 3, ...). For each number of layers, calculate the total white chocolate and dark chocolate required for both possible coloring patterns. Check if Monocarp has enough chocolate for at least one of these patterns.",
            "level5": "The maximum number of layers will be relatively small because the layer sizes (and thus chocolate costs) grow exponentially. The total chocolate needed quickly exceeds the available `10^6` kg. This suggests a simple loop iterating on the number of layers will be efficient enough."
        },
        "summary": {
            "problem_statement": "Monocarp bakes a New Year cake with at least one layer. Layer sizes start at 1 for the top, then 2, 4, and so on, doubling with each lower layer. Each layer of size `k` requires `k` kg of chocolate, either white or dark. Chocolate types must strictly alternate between adjacent layers. Given `a` kg of white chocolate and `b` kg of dark chocolate, find the maximum number of layers the cake can have.",
            "input_format": {
                "description": "The first line contains the number of test cases `t`. Each subsequent line contains two integers `a` and `b` representing the available white and dark chocolate.",
                "structure": [
                    {
                        "name": "t",
                        "type": "integer",
                        "description": "Number of test cases"
                    },
                    {
                        "name": "a",
                        "type": "integer",
                        "description": "Kilograms of white chocolate"
                    },
                    {
                        "name": "b",
                        "type": "integer",
                        "description": "Kilograms of dark chocolate"
                    }
                ]
            },
            "output_format": {
                "description": "For each test case, output a single integer: the maximum possible number of layers in the cake.",
                "structure": [
                    {
                        "name": "max_layers",
                        "type": "integer",
                        "description": "Maximum number of layers"
                    }
                ]
            },
            "constraints": {
                "time_limit": "2 seconds",
                "memory_limit": "512 megabytes",
                "bounds": [
                    {
                        "variable": "t",
                        "range": "[1, 10^4]"
                    },
                    {
                        "variable": "a",
                        "range": "[1, 10^6]"
                    },
                    {
                        "variable": "b",
                        "range": "[1, 10^6]"
                    }
                ]
            },
            "sample_cases": [
                {
                    "input": "1 1",
                    "output": "1"
                },
                {
                    "input": "1 2",
                    "output": "2"
                },
                {
                    "input": "3 1",
                    "output": "2"
                },
                {
                    "input": "4 3",
                    "output": "2"
                },
                {
                    "input": "5 2",
                    "output": "3"
                },
                {
                    "input": "1000000 1000000",
                    "output": "20"
                },
                {
                    "input": "1000000 1",
                    "output": "2"
                }
            ],
            "key_requirements": [
                "Maximize the total number of layers.",
                "Layer sizes must be 1, 2, 4, 8, ... (powers of 2).",
                "Each layer `k` requires `k` kg of chocolate.",
                "Chocolate types must alternate between adjacent layers.",
                "Must have enough `a` (white) and `b` (dark) chocolate for the chosen configuration."
            ]
        },
        "analysis": {
            "key_observation": "The layer sizes grow exponentially (powers of 2). Because the available chocolate `a, b` are limited to `10^6`, the maximum number of layers `N` cannot be very large. The sum of powers of 2 up to 2^(N-1) becomes roughly 2^N. For N=20 layers, the total chocolate is ~2 million kg. For N=21, ~4 million kg. Thus, `N` will not exceed approximately 20-21. This makes an iterative approach feasible. There are only two possible alternating patterns: either the top layer is white, or the top layer is dark. We need to check both.",
            "edge_cases": [
                "Only one layer: always possible if `a >= 1` or `b >= 1` (since layer size is 1).",
                "One chocolate type is much scarcer than the other: The scarcer type will limit the number of layers.",
                "Both chocolate types are abundant: The number of layers will be limited by the total geometric sum.",
                "Smallest `a, b` (e.g., `a=1, b=1`): Max 1 layer.",
                "Largest `a, b` (e.g., `a=10^6, b=10^6`): Max 20 layers (as per example)."
            ],
            "naive_failures": [
                "Trying to enumerate all possible chocolate assignments for layers: This would be `2^N` patterns, which is too slow even for `N=20` (2^20 is over 1 million). The key is that only two patterns (top white or top dark) are valid for alternating types.",
                "Incorrectly summing chocolate costs: If not careful with the alternating logic, one might sum all costs to one type.",
                "Integer overflow for layer costs or total sums: While `N` is small, `2^N` can exceed standard 32-bit integer limits (up to `2^31-1`). `long long` should be used for sums to be safe."
            ],
            "problem_category": {
                "primary": "Greedy",
                "secondary": [
                    "Simulation",
                    "Number Theory",
                    "Powers of Two"
                ],
                "subcategory": "Iterative Search"
            },
            "complexity_analysis": {
                "constraints": {
                    "t": "10^4",
                    "a_b": "10^6"
                },
                "expected_time": "O(T * log(max(A, B)))",
                "expected_space": "O(1)"
            }
        },
        "solution": {
            "language": "C++",
            "approach": "The solution involves an iterative approach. We start by considering 1 layer, then 2, and so on. For each `n` layers, we calculate the total white and dark chocolate needed for two scenarios: 1) the top layer is white, and 2) the top layer is dark (ensuring alternation in both cases). If either scenario is feasible with the available `a` and `b` chocolate, we update the maximum number of layers and continue to `n+1` layers. If neither scenario is feasible, we stop, and the current maximum number of layers is the answer.",
            "time_complexity": "O(T * log(max(A, B))). For each test case, we iterate at most around 21-22 times (since 2^20 is approximately 1 million, and 2^21 is 2 million). This logarithmic factor dominates the per-test case complexity.",
            "space_complexity": "O(1). Only a few variables are used to store current layer cost and cumulative chocolate requirements.",
            "key_insights": [
                "Layer costs grow as powers of two, limiting the maximum number of layers.",
                "Only two overall alternating patterns exist: starting with white or starting with dark.",
                "Iteratively checking increasing number of layers is efficient due to small max layers."
            ],
            "code": "#include <iostream>\n#include <algorithm>\n\nvoid solve() {\n    long long a, b; // Use long long for chocolate amounts to be safe, though 10^6 fits int.\n    std::cin >> a >> b;\n\n    int max_layers = 0;\n\n    long long current_layer_cost = 1;\n    int current_layer_idx = 0; // 0-indexed for layer logic (0, 1, 2, ...)\n\n    // Variables to track chocolate needed for two main patterns\n    // Pattern 1: Top layer is White (W D W D ...)\n    long long white_needed_if_top_is_white = 0;\n    long long dark_needed_if_top_is_white = 0;\n\n    // Pattern 2: Top layer is Dark (D W D W ...)\n    long long white_needed_if_top_is_dark = 0;\n    long long dark_needed_if_top_is_dark = 0;\n\n    while (true) {\n        // Determine which chocolate type the current layer (current_layer_idx) uses\n        // for each of the two patterns.\n        if (current_layer_idx % 2 == 0) { // Even index: layer 0, 2, 4, ...\n            // For Pattern 1 (W D W D ...), even-indexed layers are White\n            white_needed_if_top_is_white += current_layer_cost;\n            // For Pattern 2 (D W D W ...), even-indexed layers are Dark\n            dark_needed_if_top_is_dark += current_layer_cost;\n        } else { // Odd index: layer 1, 3, 5, ...\n            // For Pattern 1 (W D W D ...), odd-indexed layers are Dark\n            dark_needed_if_top_is_white += current_layer_cost;\n            // For Pattern 2 (D W D W ...), odd-indexed layers are White\n            white_needed_if_top_is_dark += current_layer_cost;\n        }\n\n        // Check if (current_layer_idx + 1) layers are possible with current chocolate totals\n        bool possible_with_top_white = (a >= white_needed_if_top_is_white) && (b >= dark_needed_if_top_is_white);\n        bool possible_with_top_dark = (a >= white_needed_if_top_is_dark) && (b >= dark_needed_if_top_is_dark);\n\n        if (possible_with_top_white || possible_with_top_dark) {\n            // If at least one pattern is possible, update max_layers\n            max_layers = current_layer_idx + 1;\n            \n            // Prepare for the next layer\n            current_layer_idx++;\n            // Heuristic check to prevent `current_layer_cost` from growing excessively large\n            // before it's guaranteed to exceed `max(a, b)` for sums. Total needed for next\n            // check would be at least `current_layer_cost` + some previous sum.\n            // If `current_layer_cost` alone is too large, no point in continuing.\n            if (current_layer_cost > 2000000LL) { // A value safely above 2 * max(a,b) (2 * 10^6)\n                break;\n            }\n            current_layer_cost *= 2;\n        } else {\n            // If neither pattern is possible, we can't add any more layers\n            break;\n        }\n    }\n    std::cout << max_layers << std::endl;\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n",
            "explanation": {
                "algorithm_steps": [
                    "Initialize `max_layers` to 0. Initialize `current_layer_cost` to 1 (for the smallest layer size) and `current_layer_idx` to 0 (for 0-indexed layer counting).",
                    "Initialize four `long long` variables to accumulate chocolate costs for two patterns: `white_needed_if_top_is_white`, `dark_needed_if_top_is_white`, `white_needed_if_top_is_dark`, `dark_needed_if_top_is_dark` to 0.",
                    "Enter a `while(true)` loop to iteratively check increasing numbers of layers:",
                    "Inside the loop, determine which cumulative chocolate count to update. If `current_layer_idx` is even (0, 2, 4, ...), this layer contributes `current_layer_cost` to white chocolate if the top is white, or to dark chocolate if the top is dark.",
                    "If `current_layer_idx` is odd (1, 3, 5, ...), this layer contributes `current_layer_cost` to dark chocolate if the top is white, or to white chocolate if the top is dark.",
                    "After updating costs, check if `(current_layer_idx + 1)` layers are possible. This involves two checks: (1) `a >= white_needed_if_top_is_white` AND `b >= dark_needed_if_top_is_white`, and (2) `a >= white_needed_if_top_is_dark` AND `b >= dark_needed_if_top_is_dark`.",
                    "If at least one of these two scenarios is possible, update `max_layers = current_layer_idx + 1`. Then increment `current_layer_idx` and double `current_layer_cost` to prepare for the next iteration.",
                    "If neither scenario is possible, break out of the loop, as no more layers can be added.",
                    "After the loop, print `max_layers`."
                ],
                "edge_cases_handled": [
                    "The minimum case of 1 layer is handled correctly: in the first iteration, `max_layers` will become 1, assuming `a` or `b` is at least 1.",
                    "Cases where one chocolate type is severely limited are handled by checking both `a` and `b` against their respective required amounts for each pattern.",
                    "The loop terminates when `current_layer_cost` becomes too large (meaning future layers are unaffordable) or when total chocolate needed exceeds available amounts, effectively handling cases with small or large `a, b` values.",
                    "Using `long long` for chocolate sums prevents overflow, as total chocolate can reach around `2 * 10^6` (`2^21 - 1`), which exceeds `2^31-1` if only `int` were used."
                ]
            },
            "test_verification": {
                "input_1_1": "Output: 1. Correct. (e.g., Layer 0: size 1, White. Need W=1, D=0. Have W=1, D=1. Possible.)",
                "input_1_2": "Output: 2. Correct. (Layer 0: size 1, White; Layer 1: size 2, Dark. Need W=1, D=2. Have W=1, D=2. Possible.)",
                "input_5_2": "Output: 3. Correct. (Layer 0: size 1, White; Layer 1: size 2, Dark; Layer 2: size 4, White. Need W=1+4=5, D=2. Have W=5, D=2. Possible.)",
                "input_1000000_1000000": "Output: 20. Correct. The sum of powers of 2 up to 2^19 is 2^20-1 (approx 1 million). This allows 20 layers for some configurations.",
                "input_1000000_1": "Output: 2. Correct. Limited by the available 1kg of dark chocolate. E.g., Top=Dark(1kg), Bottom=White(2kg). Valid. For 3 layers, needs 1+4=5kg dark, or 2kg dark, both invalid due to 1kg limit."
            }
        }
    },
    "code": "#include <bits/stdc++.h>\n\nvoid solve() {\n    long long a, b;\n    std::cin >> a >> b;\n\n    long long current_white_needed_if_top_W = 0;\n    long long current_dark_needed_if_top_W = 0;\n    long long current_layer_size = 1;\n    int max_layers = 0;\n\n    // Loop through possible number of layers.\n    // layer_idx corresponds to the power of 2 for the current layer (0 for 2^0, 1 for 2^1, etc.)\n    // num_layers = layer_idx + 1\n    // The maximum possible number of layers is small (around 20-21) because total chocolate capacity is 2 * 10^6.\n    // Iterating up to 60 is a safe upper bound for powers of 2 for long long, though loop will break much earlier.\n    for (int layer_idx = 0; layer_idx < 60; ++layer_idx) {\n        int num_layers = layer_idx + 1;\n\n        if (layer_idx % 2 == 0) {\n            // Layers at even 0-indexed positions (0, 2, 4...) are white if the top layer (0th) is white.\n            current_white_needed_if_top_W += current_layer_size;\n        } else {\n            // Layers at odd 0-indexed positions (1, 3, 5...) are dark if the top layer (0th) is white.\n            current_dark_needed_if_top_W += current_layer_size;\n        }\n\n        // Check if `num_layers` is possible with top layer white (W, D, W, ...)\n        bool possible_with_top_W = (a >= current_white_needed_if_top_W && b >= current_dark_needed_if_top_W);\n        \n        // Check if `num_layers` is possible with top layer dark (D, W, D, ...)\n        // In this case, the costs for white and dark chocolate are swapped compared to top_W.\n        bool possible_with_top_D = (a >= current_dark_needed_if_top_W && b >= current_white_needed_if_top_W);\n\n        if (possible_with_top_W || possible_with_top_D) {\n            max_layers = num_layers;\n        } else {\n            // If `num_layers` is not possible, then no greater number of layers is possible either,\n            // as chocolate requirements only increase with more layers.\n            break;\n        }\n        \n        // Prepare for the next layer size.\n        // Check for potential overflow of current_layer_size if it were to exceed maximum long long value.\n        // For practical limits of a, b (10^6), this check will not be hit as `break` happens much earlier.\n        if (current_layer_size > (LLONG_MAX / 2)) {\n            break;\n        }\n        current_layer_size *= 2;\n    }\n\n    std::cout << max_layers << std::endl;\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}"
}